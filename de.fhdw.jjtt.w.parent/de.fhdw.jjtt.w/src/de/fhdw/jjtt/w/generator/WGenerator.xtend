/*
 * 0 * generated by Xtext 2.13.0
 */
package de.fhdw.jjtt.w.generator

import de.fhdw.jjtt.w.w.Assignment
import de.fhdw.jjtt.w.w.Loop
import de.fhdw.jjtt.w.w.NamedProgram
import de.fhdw.jjtt.w.w.Reference
import de.fhdw.jjtt.w.w.Sequence
import de.fhdw.jjtt.w.w.Variable
import java.util.ArrayList
import java.util.List
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension de.fhdw.jjtt.w.Utils.*
import static extension de.fhdw.jjtt.w.XUtils.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val path = resource.URI.path
		val fileName = path.substring(path.lastIndexOf('/') + 1, path.length - 2)
		val content = '''
			import turingmaschine.*;
			import de.fhdw.jjtt.w.w.*;
			
			public class «fileName» {
				«FOR p : resource.allContents.toIterable.filter(NamedProgram)»
					«generateNamedProgram(p)»
				«ENDFOR»
			}
		'''
		fsa.generateFile('''../src/main/java/«fileName».java''', content)
	}

	def String generateParams(EList<Variable> list) {
		val iterator = list.iterator
		var ret = ""
		while (iterator.hasNext) {
			ret += iterator.next
			if (iterator.hasNext) {
				ret += ", "
			}
		}
		ret
	}

	def String generateNamedProgram(NamedProgram program) {
		if (program.name == "main" && program.params.size == 0) {
			'''
			public static void main(String[] args) {
				«declareVariables(getVariables(program.program))»
				«generateProgram(program.program)»
			}'''
		} else {
			'''
			public TuringMaschine create«program.getName.toFirstUpper»Machine(«generateParams(program.params)») {
				«declareVariables(getVariables(program.program))»
				return «generateProgram(program.getProgram)»
			}'''
		}
	}

	def dispatch List<String> getVariables(Assignment a) {
		// TODO Parameter des aktuellen namedPrograms müssen hier noch berücksichtigt werden
		val ret = new ArrayList<String>
		ret.add(a.toBeAssigned.name)

		val val1 = a.val1
		if(val1 instanceof Variable) ret.add(val1.name)

		val val2 = a.val2
		if(val2 instanceof Variable) ret.add(val2.name)

		ret
	}

	def dispatch List<String> getVariables(Sequence s) {
		getVariables(s.p1).concat(getVariables(s.p2))
	}

	def dispatch List<String> getVariables(Reference r) {
		r.params.filter[it instanceof Variable].map[(it as Variable).name].toList
	}

	def dispatch List<String> getVariables(Loop l) {
		val ret = getVariables(l.prog)
		ret.add(l.^var.name)
		ret
	}

	def declareVariables(List<String> list) {
		val ret = new StringBuilder;
		list.stream.distinct.forEach [
			it -> {
				ret.append('''ChangeableBand «it» = ChangeableBand.create();''')
				ret.append("\n")
			}
		]
		ret
	}

	def dispatch String generateProgram(Reference reference) {
		// TODO
	}

	def dispatch String generateProgram(Assignment assignment) {
		'''
			TuringMaschinen.create«IF assignment.op == "+"»Add«ENDIF»«IF assignment.op == "-"»Sub«ENDIF»().createStartKonfiguration(«assignment.val1.valueHavingThingToString», «assignment.val2.valueHavingThingToString», «assignment.toBeAssigned.name»)
		'''
	}

	def dispatch String generateProgram(Loop loop) {
		'''TouringMachine.createWhile(«loop.^var», «generateProgram(loop.prog)»)
		'''
	}

	def dispatch String generateProgram(Sequence sequence) {
		'''TouringMachine.createSeq(«generateProgram(sequence.p1)», «generateProgram(sequence.p2)»)
		'''
	}

}
