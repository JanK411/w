/*
 * 0 * generated by Xtext 2.13.0
 */
package de.fhdw.jjtt.w.generator

import de.fhdw.jjtt.w.w.Assertion
import de.fhdw.jjtt.w.w.Assignment
import de.fhdw.jjtt.w.w.Loop
import de.fhdw.jjtt.w.w.NamedProgram
import de.fhdw.jjtt.w.w.Print
import de.fhdw.jjtt.w.w.Reference
import de.fhdw.jjtt.w.w.Sequence
import java.util.List
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension de.fhdw.jjtt.w.XUtils.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WGenerator extends AbstractGenerator {

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val path = resource.URI.path
		val fileName = path.substring(path.lastIndexOf('/') + 1, path.length - 2)
		val content = '''
			import org.junit.Test;
			import static org.junit.Assert.assertEquals;
			import turingmaschine.*;
			import turingmaschine.band.*;
			
			public class «fileName» {
				«FOR p : resource.allContents.toIterable.filter(NamedProgram)»
					«generateNamedProgram(p)»
				«ENDFOR»
			}
		'''
		fsa.generateFile('''../src/main/java/«fileName».java''', content)
	}

	def String generateNamedProgram(NamedProgram program) {
		'''
		«IF !program.outputs.empty»@Test«ENDIF»
		public «IF program.outputs.empty»TuringMaschineMitBand«ELSE»void«ENDIF» «program.getName»(«program.params.map["ChangeableBand "+it.name].join(", ")») {
			«declareVariables(program.program.variables.filter[!program.params.map[it.name].contains(it)].toList)»
			«IF program.outputs.empty»return «generateProgram(program.program)»;
			«ELSE»«generateProgram(program.program)».simuliere();
			«program.outputs.map[it.declare].reduce[s1, s2|s1+"\n"+s2]»
			«ENDIF»
		}'''
	}

	def dispatch String declare(Assertion a) {
		'''assertEquals(Integer.valueOf(«a.expected.value»), Integer.valueOf(«a.real.name».toString()));'''
	}

	def dispatch String declare(Print p) {
		'''System.out.println("«p.variable.name» = " + «p.variable.name».toString());'''
	}

	def printAllVariables(List<String> strings) {
		'''«FOR s : strings.stream.distinct.collect(Collectors.toList)»
		System.out.println("«s»" + " = " + «s»);
		«ENDFOR»'''
	}

	def declareVariables(List<String> list) {
		val ret = new StringBuilder;
		list.stream.distinct.forEach [
			it -> {
				ret.append('''ChangeableBand «it» = ChangeableBand.create("0");''')
				ret.append("\n")
			}
		]
		ret
	}

	def dispatch String generateProgram(Reference reference) {
		'''«IF reference.isInBuild»TuringMaschinen.«ENDIF»«reference.name»(«reference.params.map[it.valueHavingThingToString].join(", ")»)'''
	}

	def dispatch String generateProgram(Assignment assignment) {
		'''TuringMaschinen.create«IF assignment.op == "+"»Add«ENDIF»«IF assignment.op == "-"»Sub«ENDIF»(«assignment.val1.valueHavingThingToString», «assignment.val2.valueHavingThingToString», «assignment.toBeAssigned.name»)'''
	}

	def dispatch String generateProgram(Loop loop) {
		'''TuringMaschinen.createWhile«IF loop.op == '==0'»Equal«ELSE»NotEqual«ENDIF»(«loop.^var.valueHavingThingToString», «generateProgram(loop.prog)»)'''
	}

	def dispatch String generateProgram(Sequence sequence) {
		'''
		TuringMaschinen.createSeq(
				«generateProgram(sequence.p1)»,
				«generateProgram(sequence.p2)»
		)'''
	}

}
