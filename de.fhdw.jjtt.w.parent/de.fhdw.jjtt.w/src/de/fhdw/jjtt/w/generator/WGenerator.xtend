/*
 * 0 * generated by Xtext 2.13.0
 */
package de.fhdw.jjtt.w.generator

import de.fhdw.jjtt.w.w.Assertion
import de.fhdw.jjtt.w.w.Assignment
import de.fhdw.jjtt.w.w.Loop
import de.fhdw.jjtt.w.w.Print
import de.fhdw.jjtt.w.w.Reference
import de.fhdw.jjtt.w.w.Sequence
import de.fhdw.jjtt.w.w.NamedProgram
import java.util.List
import java.util.stream.Collectors
import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext

import static extension de.fhdw.jjtt.w.XUtils.*

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class WGenerator extends AbstractGenerator {

	/**
	 * Einstiegs-Operation für den Generator. Hier werden zunächst die evtl. benötigten Importe generiert, 
	 * danach werden für alle NamedPrograms die dazugehörigen Operationen und Methoden definiert. 
	 */
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val path = resource.URI.path
		val fileName = path.substring(path.lastIndexOf('/') + 1, path.length - 2)
		val content = '''
			import org.junit.Test;
			import static org.junit.Assert.assertEquals;
			import turingmaschine.*;
			import turingmaschine.band.*;
			
			public class «fileName» {
				«FOR p : resource.allContents.toIterable.filter(NamedProgram)»
					«generateNamedProgram(p)»
				«ENDFOR»
			}
		'''
		fsa.generateFile('''../src/main/java/«fileName».java''', content)
	}

	/**
	 * Generiert die Operation und Methode für ein NamedProgram. Dabei werden zunächst alle Variablen deklariert, 
	 * welche in diesem NamedProgram verwendet werden. Ebenso wird hier unterschieden, 
	 * ob die generierte Operation als ausführbaren JUnit-Test gekennzeichnet wird, oder ob die Operation eine TuringMaschine erstellt und diese zurückgibt.
	 */
	def String generateNamedProgram(NamedProgram program) {
		'''
		«IF program.comment !== null»/**«program.comment»*/«ENDIF»
		«IF !program.outputs.empty»@Test«ENDIF»
		public «IF program.outputs.empty»TuringMaschineMitBand«ELSE»void«ENDIF» «program.getName»(«program.params.map["ChangeableBand "+it.name].join(", ")») {
			«declareVariables(program.program.variables.filter[!program.params.map[it.name].contains(it)].toList)»
			«IF program.outputs.empty»return «generateProgram(program.program)»;
			«ELSE»«generateProgram(program.program)».simuliere«IF program.print»MitAusgabe«ENDIF»();
				«program.outputs.map[it.declare].reduce[s1, s2|s1+"\n"+s2]»
			«ENDIF»
		}'''
	}

	/**
	 * generiert assertEquals für JUnit-Tests.
	 */
	def dispatch String declare(Assertion a) {
		'''assertEquals(Integer.valueOf(«a.expected.value»), Integer.valueOf(«a.real.name».getBandInhalt()));'''
	}

	/**
	 * generiert eine Konsolen-ausgabe für eine Variable.
	 */
	def dispatch String declare(Print p) {
		'''System.out.println("«p.variable.name» = " + «p.variable.name».getBandInhalt());'''
	}

	/**
	 * generiert Konsolen-ausgaben für die Liste der strings, welche als Parameter übergeben wird. 
	 * Doppelte Elemente werden herausgefiltert. 
	 */
	def printAllVariables(List<String> strings) {
		'''«FOR s : strings.stream.distinct.collect(Collectors.toList)»
		System.out.println("«s»" + " = " + «s»);
		«ENDFOR»'''
	}

	/**
	 * generiert Deklarationen für alle Variablen-Namen der Liste der Parameter und weißt ihnen den Wert 0 zu.
	 * Doppelte Elemente werden ignoriert.
	 */
	def declareVariables(List<String> list) {
		val ret = new StringBuilder;
		list.stream.distinct.forEach [
			it -> {
				ret.append('''ChangeableBand «it» = ChangeableBand.create("0");''')
				ret.append("\n")
			}
		]
		ret
	}

	/**
	 * generiert die Operationsaufrufe, die Aufgrund einer Referenz entstehen.
	 */
	def dispatch String generateProgram(Reference reference) {
		'''«reference.name»(«reference.params.map[it.valueHavingThingToString].join(", ")»)'''
	}

	/**
	 * generiert eine Add- oder Sub-Maschine, je nach Operator des Assignments.
	 */
	def dispatch String generateProgram(Assignment assignment) {
		'''TuringMaschinen.create«IF assignment.op == "+"»Add«ENDIF»«IF assignment.op == "-"»Sub«ENDIF»(«assignment.val1.valueHavingThingToString», «assignment.val2.valueHavingThingToString», «assignment.toBeAssigned.name»)'''
	}

	/**
	 * generiert eine WhileEqual- oder WhileNotEqual-Maschine, je nach Operator des Loops.
	 */
	def dispatch String generateProgram(Loop loop) {
		'''TuringMaschinen.createWhile«IF loop.op == '==0'»Equal«ELSE»NotEqual«ENDIF»(«loop.^var.valueHavingThingToString», «generateProgram(loop.prog)»)'''
	}

	/**
	 * generiert eine Sequence-Maschine, welche die zwei Programme der Sequence hintereinander ausführen kann.
	 */
	def dispatch String generateProgram(Sequence sequence) {
		'''
		TuringMaschinen.createSeq(
				«generateProgram(sequence.p1)»,
				«generateProgram(sequence.p2)»
		)'''
	}

}
