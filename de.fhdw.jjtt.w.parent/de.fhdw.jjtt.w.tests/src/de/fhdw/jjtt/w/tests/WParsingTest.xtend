/*
 * generated by Xtext 2.13.0
 */
package de.fhdw.jjtt.w.tests

import com.google.inject.Inject
import de.fhdw.jjtt.w.generator.WGenerator
import de.fhdw.jjtt.w.w.File
import org.eclipse.xtext.testing.InjectWith
import org.eclipse.xtext.testing.XtextRunner
import org.eclipse.xtext.testing.util.ParseHelper
import org.junit.Assert
import org.junit.Test
import org.junit.runner.RunWith

import static org.junit.Assert.*

import static extension de.fhdw.jjtt.w.XUtils.*

@RunWith(XtextRunner)
@InjectWith(WInjectorProvider)
class WParsingTest {
	@Inject
	ParseHelper<File> parseHelper
	var gen = new WGenerator()

	@Test
	def testAddierer() {
		val input = parseHelper.parse('''
		main() {
			x = 5 + 3;
			y = 6 - x
			assert(8, x)
			assert(0, y)
		}''')

		val main = gen.generateNamedProgram(input.programs.findFirst[it.name == "main"])
		println(main)

		val expected = '''	
		@Test
		public void main() {
			ChangeableBand x = ChangeableBand.create("0");
			ChangeableBand y = ChangeableBand.create("0");
			TuringMaschinen.createSeq(
					TuringMaschinen.createAdd(ChangeableBand.create("5"), ChangeableBand.create("3"), x),
					TuringMaschinen.createSub(ChangeableBand.create("6"), x, y)
			).simuliere();
				assertEquals(Integer.valueOf(8), Integer.valueOf(x.getBandInhalt()));
				assertEquals(Integer.valueOf(0), Integer.valueOf(y.getBandInhalt()));
		}'''

		assertEquals(expected.trimWhitespaces, main.trimWhitespaces);
	}

	@Test
	def testMultiply() {
		val input = parseHelper.parse('''
		/"schreibt das Ergebnis der Multiplikation von f1 * f2 in das result."/
		multiply(f1, f2, result) {
			f1i = 0 + 0;
			f2i = f2 + 0;
			while f2i !=0 do
				f1i = f1i + f1;
				f2i = f2i - 1
			endwhile;
			result = f1i + 0
		}''')

		val main = gen.generateNamedProgram(input.programs.findFirst[it.name == "multiply"])
		println(main)

		val expected = '''	/**schreibt das Ergebnis der Multiplikation von f1 * f2 in das result.*/
			public TuringMaschineMitBand multiply(ChangeableBand f1, ChangeableBand f2, ChangeableBand result) {
				ChangeableBand f1i = ChangeableBand.create("0");
				ChangeableBand f2i = ChangeableBand.create("0");
				return TuringMaschinen.createSeq(
						TuringMaschinen.createAdd(ChangeableBand.create("0"), ChangeableBand.create("0"), f1i),
						TuringMaschinen.createSeq(
								TuringMaschinen.createAdd(f2, ChangeableBand.create("0"), f2i),
								TuringMaschinen.createSeq(
										TuringMaschinen.createWhileNotEqual(f2i, TuringMaschinen.createSeq(
												TuringMaschinen.createAdd(f1i, f1, f1i),
												TuringMaschinen.createSub(f2i, ChangeableBand.create("1"), f2i)
										)),
										TuringMaschinen.createAdd(f1i, ChangeableBand.create("0"), result)
								)
						)
				);
				}'''

		assertEquals(expected.trimWhitespaces, main.trimWhitespaces);

	}

	@Test
	def loadModel() {
		val result = parseHelper.parse('''
		/"testet das Multiply"/
		testMultiply() {
			x = 5 + 0;
			y = 3 + 0;
			multiply(x, y, res)
			assert(5, x)
			assert(3, y)
			assert(15, res)
		}
		
		/"schreibt das Ergebnis der Multiplikation von f1 * f2 in das result."/
		multiply(f1, f2, result) {
			f1i = 0 + 0;
			f2i = f2 + 0;
			while f2i !=0 do
				f1i = f1i + f1;
				f2i = f2i - 1
			endwhile;
			result = f1i + 0
		}''')

		assertEquals(2, result.programs.size)
		assertNotNull(result.programs.findFirst[it.name == "testMultiply"])
		assertNotNull(result.programs.findFirst[it.name == "multiply"])

		val actualTestCase = gen.generateNamedProgram(result.programs.findFirst[it.name == "testMultiply"])
		val expectedTestCase = '''
			/**testet das Multiply*/
			@Test
			public void testMultiply() {
		ChangeableBand x = ChangeableBand.create("0");
		ChangeableBand y = ChangeableBand.create("0");
		ChangeableBand res = ChangeableBand.create("0");
		TuringMaschinen.createSeq(
				TuringMaschinen.createAdd(ChangeableBand.create("5"), ChangeableBand.create("0"), x),
				TuringMaschinen.createSeq(
						TuringMaschinen.createAdd(ChangeableBand.create("3"), ChangeableBand.create("0"), y),
						multiply(x, y, res)
				)
		).simuliere();
			assertEquals(Integer.valueOf(5), Integer.valueOf(x.getBandInhalt()));
			assertEquals(Integer.valueOf(3), Integer.valueOf(y.getBandInhalt()));
			assertEquals(Integer.valueOf(15), Integer.valueOf(res.getBandInhalt()));
			}'''
		Assert.assertEquals(expectedTestCase.trimWhitespaces, actualTestCase.trimWhitespaces)
		val multiply = gen.generateNamedProgram(result.programs.findFirst[it.name == "multiply"])
		val expectedMultiply = '''
			/**schreibt das Ergebnis der Multiplikation von f1 * f2 in das result.*/
		public TuringMaschineMitBand multiply(ChangeableBand f1, ChangeableBand f2, ChangeableBand result) {
			ChangeableBand f1i = ChangeableBand.create("0");
			ChangeableBand f2i = ChangeableBand.create("0");
			return TuringMaschinen.createSeq(
					TuringMaschinen.createAdd(ChangeableBand.create("0"), ChangeableBand.create("0"), f1i),
					TuringMaschinen.createSeq(
							TuringMaschinen.createAdd(f2, ChangeableBand.create("0"), f2i),
							TuringMaschinen.createSeq(
									TuringMaschinen.createWhileNotEqual(f2i, TuringMaschinen.createSeq(
											TuringMaschinen.createAdd(f1i, f1, f1i),
											TuringMaschinen.createSub(f2i, ChangeableBand.create("1"), f2i)
									)),
									TuringMaschinen.createAdd(f1i, ChangeableBand.create("0"), result)
							)
					)
			);
			}'''
		Assert.assertEquals(expectedMultiply.trimWhitespaces, multiply.trimWhitespaces)
	}
}
